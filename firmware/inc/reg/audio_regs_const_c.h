/////////////////////////////////////////////////////////////////////////////////
// This file has been automatically generated by register_slave.pl version dc9b7d3
/////////////////////////////////////////////////////////////////////////////////

// type declaration
#ifndef __REG_CONST_T
#define __REG_CONST_T

#ifndef REG_CONST_NAME_STRING_MAX_LEN   
#define REG_CONST_NAME_STRING_MAX_LEN 64
#endif // REG_CONST_NAME_STRING_MAX_LEN
#ifndef REG_CONST_DESC_STRING_MAX_LEN
#define REG_CONST_DESC_STRING_MAX_LEN 512
#endif // REG_CONST_DESC_STRING_MAX_LEN
typedef struct {
	char name[REG_CONST_NAME_STRING_MAX_LEN];
	DWORD address;
	DWORD def;
	char desc[REG_CONST_DESC_STRING_MAX_LEN];
} reg_const_t;
typedef struct {
	char name[REG_CONST_NAME_STRING_MAX_LEN];
	char range[32];
	char def[32];
	char access[32];
	char desc[REG_CONST_DESC_STRING_MAX_LEN];
} field_const_t;
typedef struct {
	field_const_t *pfield;
	DWORD size;
} field_const_array_t;
#endif // __REG_CONST_T

#define NUM_REGS__AUDIO_REGS  39
/* { reg_const_audio_regs, 39, "audio_regs"},  */ 
static reg_const_t reg_const_audio_regs[NUM_REGS__AUDIO_REGS] = {
  {/* name */ "intr_status", /* address */ 0x44106000, /* default */ 0x00000000, /* description */ "Interrupt status register bits. \n"}, 
  {/* name */ "intr_mask_status", /* address */ 0x44106004, /* default */ 0x00000000, /* description */ "Interrupt mask status register\n"}, 
  {/* name */ "intr_clear", /* address */ 0x44106008, /* default */ 0x00000000, /* description */ "Clear interrupt status\n"}, 
  {/* name */ "intr_set", /* address */ 0x4410600c, /* default */ 0x00000000, /* description */ "Set interrupt status\n"}, 
  {/* name */ "intr_mask_set", /* address */ 0x44106010, /* default */ 0x00000000, /* description */ "Set interrupt mask\n"}, 
  {/* name */ "intr_mask_clear", /* address */ 0x44106014, /* default */ 0x00000000, /* description */ "Set interrupt mask\n"}, 
  {/* name */ "misc_ctrl0", /* address */ 0x44106040, /* default */ 0x0001e000, /* description */ "Interrupt status register bits. \n"}, 
  {/* name */ "aurx_ctrl0", /* address */ 0x44106044, /* default */ 0x0a027109, /* description */ "Audio Rx Control\n"}, 
  {/* name */ "aurx_ctrl1", /* address */ 0x44106048, /* default */ 0x31004064, /* description */ "Audio Rx Control\n"}, 
  {/* name */ "aenc_ctrl0", /* address */ 0x4410604c, /* default */ 0x031e0fda, /* description */ "ADPCM Encoder Control\n"}, 
  {/* name */ "aenc_ctrl1", /* address */ 0x44106050, /* default */ 0x000007ff, /* description */ "ADPCM Encoder Control\n"}, 
  {/* name */ "aenc_stat0", /* address */ 0x44106054, /* default */ 0x00000000, /* description */ "ADPCM Encoder Control\n"}, 
  {/* name */ "adec_ctrl0", /* address */ 0x44106058, /* default */ 0x3ff9c1fb, /* description */ "ADPCM Decoder Control\n"}, 
  {/* name */ "adec_ctrl1", /* address */ 0x4410605c, /* default */ 0x07f81000, /* description */ "ADPCM Decoder Control\n"}, 
  {/* name */ "adec_stat0", /* address */ 0x44106060, /* default */ 0x00000000, /* description */ "ADPCM Decoder Status\n"}, 
  {/* name */ "autx_ctrl0", /* address */ 0x44106064, /* default */ 0x0e0a6298, /* description */ "Audio Tx Control\n"}, 
  {/* name */ "autx_ctrl1", /* address */ 0x44106068, /* default */ 0x00100000, /* description */ "Audio Tx Control\n"}, 
  {/* name */ "autx_ctrl2", /* address */ 0x4410606c, /* default */ 0x08001000, /* description */ "Audio Tx Control\n"}, 
  {/* name */ "autx_ctrl3", /* address */ 0x44106070, /* default */ 0x00200400, /* description */ "Audio Tx Control\n"}, 
  {/* name */ "autx_afifo_stat0", /* address */ 0x44106074, /* default */ 0x00000000, /* description */ "Audio Tx FIFO Status\n"}, 
  {/* name */ "autx_rfb_ctrl0", /* address */ 0x44106078, /* default */ 0x0cc8c6a3, /* description */ "Audio Tx Rate Feedback Control\n"}, 
  {/* name */ "autx_rfb_ctrl1", /* address */ 0x4410607c, /* default */ 0x00000319, /* description */ "Audio Tx Rate Feedback Control\n"}, 
  {/* name */ "autx_rfb_stat0", /* address */ 0x44106080, /* default */ 0x00000000, /* description */ "Audio Tx Rate Feedback Status\n"}, 
  {/* name */ "autx_rfb_stat1", /* address */ 0x44106084, /* default */ 0x00000000, /* description */ "Audio Tx Rate Feedback Status\n"}, 
  {/* name */ "autx_rfb_stat2", /* address */ 0x44106088, /* default */ 0x00000000, /* description */ "Audio Tx Rate Feedback Status\n"}, 
  {/* name */ "autx_sdm_ctrl0", /* address */ 0x4410608c, /* default */ 0x00011030, /* description */ "Audio Tx Rate Sigma Delta Modulator Control\n"}, 
  {/* name */ "autx_sdm_stat0", /* address */ 0x44106090, /* default */ 0x00000000, /* description */ "Audio Tx Rate Sigma Delta Modulator status\n"}, 
  {/* name */ "adec_rate_ctrl0", /* address */ 0x44106094, /* default */ 0x000103e8, /* description */ "ADPCM Decoder Rate Control\n"}, 
  {/* name */ "adec_dma_ctrl0", /* address */ 0x441060c0, /* default */ 0x00000000, /* description */ "ADPCM Encoder and Decoder DMA status\n"}, 
  {/* name */ "adec_dma_stat0", /* address */ 0x441060c4, /* default */ 0x00000000, /* description */ "ADPCM Encoder and Decoder DMA status\n"}, 
  {/* name */ "dma_read", /* address */ 0x441060c8, /* default */ 0x00000000, /* description */ "ADPCM DMA read\n"}, 
  {/* name */ "adec_dma_write", /* address */ 0x441060cc, /* default */ 0x00000000, /* description */ "ADPCM DMA write\n"}, 
  {/* name */ "pdm_ctrl0", /* address */ 0x441060d0, /* default */ 0x3010203f, /* description */ "PDM controls\n"}, 
  {/* name */ "pdm_ctrl1", /* address */ 0x441060d4, /* default */ 0x00000031, /* description */ "PDM controls\n"}, 
  {/* name */ "autx_sm_ctrl0", /* address */ 0x441060d8, /* default */ 0x0007ff10, /* description */ "Audio Tx Read Shared Memory Interface Controls\n"}, 
  {/* name */ "autx_sm_stat0", /* address */ 0x441060dc, /* default */ 0x00000000, /* description */ "Audio Tx Read Shared Memory Interface Status\n"}, 
  {/* name */ "autx_wrsm_ctrl0", /* address */ 0x441060e0, /* default */ 0x7f8ffe50, /* description */ "Audio Tx Write Shared Memory Interface Controls\n"}, 
  {/* name */ "autx_wrsm_ctrl1", /* address */ 0x441060e4, /* default */ 0x000303e8, /* description */ "Audio Tx Write Shared Memory Interface Controls\n"}, 
  {/* name */ "autx_wrsm_stat0", /* address */ 0x441060e8, /* default */ 0x00000000, /* description */ "Audio Tx Read Shared Memory Interface Status\n"}
};

field_const_t field_const_audio_regs__intr_status[]  = {
  {/* name */ "intr", /* range */ "[21:0]", /* default */ "0x0", /* access */ "read-only", /* description */ "0: Packet FIFO has over/underflowed\n1: DMA FIFO overflowed\n2: DMA FIFO underflowed\n3: "last byte" was on a RIGHT byte - perhaps "i_ctlq_adec_size" was not set correctly\n4: In FIFO under/overflowed (at input of decoder)\n5: PCM FIFO under/overflowed (at output of decoder)\n6: Got too many read grants - some internal state machine didn't wait properly\n7: Got too many read valids - some internal state machine didn't wait properly\n8: 0: output FIFO overflow\n9: output FIFO underflow\n10: offset PPM positive saturation\n11: offset PPM negative saturation\n12: Encoder Read Address LSBs FIFO overflow error - this means the latency between getting read acks and getting actual read valid's is too high\n13: Encoder Read Address LSBS FIFO underflow error - probably means we came out of reset while there were previous reads issued                 \n14: Decoder Read Address LSBs FIFO overflow error - this means the latency between getting read acks and getting actual read valid's is too high\n15: Decoder Read Address LSBS FIFO underflow error - probably means we came out of reset while there were previous reads issued                 \n16: Audio Tx Read Shared Mem interface Packet FIFO over/underflowed\n17: Audio Tx Read Shared Mem interface DMA FIFO overflowed\n18: Audio Tx Read Shared Mem interface DMA FIFO underflowed\n19: Audio Tx Write Shared Mem interface Out FIFO underflowed - Audio Tx datapath pulled data too fast - or not enough raw data was DMA'd in.\n20: Audio Tx Write Shared Mem interface DMA FIFO underflowed\n21: Audio Tx Write Shared Mem interface DMA FIFO overflowed - DMA'd in too many samples, before interface had a chance to transfer them to the Shared Memory\n\n"}, 
  {/* name */ "dummy_field", /* range */ "[23:22]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__intr_mask_status[]  = {
  {/* name */ "intr", /* range */ "[21:0]", /* default */ "0x0", /* access */ "read-only", /* description */ "0: Packet FIFO has over/underflowed\n1: DMA FIFO overflowed\n2: DMA FIFO underflowed\n3: "last byte" was on a RIGHT byte - perhaps "i_ctlq_adec_size" was not set correctly\n4: In FIFO under/overflowed (at input of decoder)\n5: PCM FIFO under/overflowed (at output of decoder)\n6: Got too many read grants - some internal state machine didn't wait properly\n7: Got too many read valids - some internal state machine didn't wait properly\n8: 0: output FIFO overflow\n9: output FIFO underflow\n10: offset PPM positive saturation\n11: offset PPM negative saturation\n12: Encoder Read Address LSBs FIFO overflow error - this means the latency between getting read acks and getting actual read valid's is too high\n13: Encoder Read Address LSBS FIFO underflow error - probably means we came out of reset while there were previous reads issued                 \n14: Decoder Read Address LSBs FIFO overflow error - this means the latency between getting read acks and getting actual read valid's is too high\n15: Decoder Read Address LSBS FIFO underflow error - probably means we came out of reset while there were previous reads issued                 \n16: Audio Tx Read Shared Mem interface Packet FIFO over/underflowed\n17: Audio Tx Read Shared Mem interface DMA FIFO overflowed\n18: Audio Tx Read Shared Mem interface DMA FIFO underflowed\n19: Audio Tx Write Shared Mem interface Out FIFO underflowed - Audio Tx datapath pulled data too fast - or not enough raw data was DMA'd in.\n20: Audio Tx Write Shared Mem interface DMA FIFO underflowed\n21: Audio Tx Write Shared Mem interface DMA FIFO overflowed - DMA'd in too many samples, before interface had a chance to transfer them to the Shared Memory\n\n"}, 
  {/* name */ "dummy_field", /* range */ "[23:22]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__intr_clear[]  = {
  {/* name */ "intr", /* range */ "[21:0]", /* default */ "0x0", /* access */ "read-write", /* description */ "Sampling finished\n"}, 
  {/* name */ "dummy_field", /* range */ "[23:22]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__intr_set[]  = {
  {/* name */ "intr", /* range */ "[21:0]", /* default */ "0x0", /* access */ "read-write", /* description */ "Sampling finished\n"}, 
  {/* name */ "dummy_field", /* range */ "[23:22]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__intr_mask_set[]  = {
  {/* name */ "intr", /* range */ "[21:0]", /* default */ "0x0", /* access */ "read-write", /* description */ "Sampling finished\n"}, 
  {/* name */ "dummy_field", /* range */ "[23:22]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__intr_mask_clear[]  = {
  {/* name */ "intr", /* range */ "[21:0]", /* default */ "0x0", /* access */ "read-write", /* description */ "Sampling finished\n"}, 
  {/* name */ "dummy_field", /* range */ "[23:22]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__misc_ctrl0[]  = {
  {/* name */ "ctlt_aurx_sreset", /* range */ "[0:0]", /* default */ "0x0", /* access */ "read-write", /* description */ "Soft-reset for Audio Rx path\n"}, 
  {/* name */ "ctlt_aenc_en", /* range */ "[1:1]", /* default */ "0x0", /* access */ "read-write", /* description */ "Audio Encoder enable\n"}, 
  {/* name */ "ctlt_aenc_restart", /* range */ "[2:2]", /* default */ "0x0", /* access */ "read-write", /* description */ "Sample FIFO empty\n"}, 
  {/* name */ "ctlt_adec_en", /* range */ "[3:3]", /* default */ "0x0", /* access */ "read-write", /* description */ "Audio Decoder enable\n"}, 
  {/* name */ "ctlt_adec_restart", /* range */ "[4:4]", /* default */ "0x0", /* access */ "read-write", /* description */ "Audio Decoder restart\n"}, 
  {/* name */ "ctlt_autx_sreset", /* range */ "[5:5]", /* default */ "0x0", /* access */ "read-write", /* description */ "Audio Tx restart (for everything in "clk_tx" clock domain)\n"}, 
  {/* name */ "ctlt_autx_sreset_spk", /* range */ "[6:6]", /* default */ "0x0", /* access */ "read-write", /* description */ "Audio Tx restart (for everything in "clk_spk" clock domain)\n"}, 
  {/* name */ "ctlt_autx_out_en", /* range */ "[7:7]", /* default */ "0x0", /* access */ "read-write", /* description */ "Audio Tx output enable\n"}, 
  {/* name */ "ctlt_autx_afifo_en_wr", /* range */ "[8:8]", /* default */ "0x0", /* access */ "read-write", /* description */ "Audio Tx asynchronous FIFO enable write\n"}, 
  {/* name */ "ctlt_autx_afifo_en_rd", /* range */ "[9:9]", /* default */ "0x0", /* access */ "read-write", /* description */ "Audio Tx asynchronous FIFO enable read\n"}, 
  {/* name */ "ctlt_autx_rfb_en", /* range */ "[10:10]", /* default */ "0x0", /* access */ "read-write", /* description */ "Audio Tx Rate Feedback enable\n"}, 
  {/* name */ "ctlt_autx_rfb_sreset", /* range */ "[11:11]", /* default */ "0x0", /* access */ "read-write", /* description */ "Audio Tx Rate Feedback soft-reset\n"}, 
  {/* name */ "ctlt_autx_sdm_en", /* range */ "[12:12]", /* default */ "0x0", /* access */ "read-write", /* description */ "Sigma Delta Modulator enable\n"}, 
  {/* name */ "ctlq_aurx_stereo", /* range */ "[13:13]", /* default */ "0x1", /* access */ "read-write", /* description */ "Stereo mode for Audio Rx\n"}, 
  {/* name */ "ctlq_aenc_stereo", /* range */ "[14:14]", /* default */ "1", /* access */ "read-write", /* description */ "Stereo mode for ADPCM encoder\n"}, 
  {/* name */ "ctlq_adec_stereo", /* range */ "[15:15]", /* default */ "0x1", /* access */ "read-write", /* description */ "Stereo mode for ADPCM decoder\n"}, 
  {/* name */ "ctlq_autx_stereo", /* range */ "[16:16]", /* default */ "0x1", /* access */ "read-write", /* description */ "Stereo mode for Audio Tx\n"}, 
  {/* name */ "ctlq_autx_i2sm_sel", /* range */ "[17:17]", /* default */ "0x0", /* access */ "read-write", /* description */ "Drive I2S Master core from Audio Tx. \n"}, 
  {/* name */ "ctlq_autx_i2ss_sel", /* range */ "[18:18]", /* default */ "0x0", /* access */ "read-write", /* description */ "Drive I2S Slave core from Audio Tx. \n"}, 
  {/* name */ "ctlt_pdm_en", /* range */ "[19:19]", /* default */ "0x0", /* access */ "read-write", /* description */ "PDM enable. If we want to use Microphone PDM, this should be enabled.\n"}, 
  {/* name */ "ctlt_pdm_clear", /* range */ "[20:20]", /* default */ "0x0", /* access */ "read-write", /* description */ "PDM clear all counters.\n"}, 
  {/* name */ "ctlt_pdm_clk_en", /* range */ "[21:21]", /* default */ "0x0", /* access */ "read-write", /* description */ "Enable PDM clock output.\n"}, 
  {/* name */ "ctlt_intr_sreset", /* range */ "[24:24]", /* default */ "0x0", /* access */ "read-write", /* description */ "Reset interrupt controller\n"}, 
  {/* name */ "dummy_field", /* range */ "[31:25]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__aurx_ctrl0[]  = {
  {/* name */ "ctlq_aurx_i2s_byp", /* range */ "[0:0]", /* default */ "0x1", /* access */ "read-write", /* description */ "If set (1), I2S input bypasses all filters. Still goes through programmable gain elements. Otherwise (0), I2S input goes through interp-by-4 and then standard Rx filters.\n"}, 
  {/* name */ "ctlq_aurx_in_format", /* range */ "[1:1]", /* default */ "0x0", /* access */ "read-write", /* description */ "input_format. 0:PDM   1:I2S\n"}, 
  {/* name */ "ctlq_aurx_cic_dec", /* range */ "[4:2]", /* default */ "0x2", /* access */ "read-write", /* description */ "0:    decimation = 20; filter_len = 77;\n\n1:    decimation = 16; filter_len = 61;\n\n2:    decimation = 10; filter_len = 37;\n\n3:    decimation =  8; filter_len = 29;\n\n4:    decimation =  5; filter_len = 17;\n\n5:    decimation =  4; filter_len = 13;\n\nelse: decimation =  2; filter_len = 5;\n\n"}, 
  {/* name */ "ctlq_aurx_dc_off", /* range */ "[22:5]", /* default */ "0x1388", /* access */ "read-write", /* description */ "DC offset to remove from CIC filter\n"}, 
  {/* name */ "ctlq_aurx_cic_shift", /* range */ "[26:23]", /* default */ "0x4", /* access */ "read-write", /* description */ "Shift CIC filter output up - after removing offset.\n"}, 
  {/* name */ "ctlq_aurx_i2s_shift", /* range */ "[29:27]", /* default */ "0x1", /* access */ "read-write", /* description */ "Shift I2S input before clipping.\n"}, 
  {/* name */ "ctlq_aurx_i2s_slave", /* range */ "[30:30]", /* default */ "0x0", /* access */ "read-write", /* description */ "If set (1), get input data from I2S Master core. Otherwise (0), get input data from I2S Slave core.\n"}, 
  {/* name */ "ctlq_aurx_i2s_d5", /* range */ "[31:31]", /* default */ "0x0", /* access */ "read-write", /* description */ "If set (1), I2S input bypasses its own interpolate-by-4 filter and shared decimate-by-5 filter. Still goes through decimate-by-2 and gain elements. Otherwise (0), I2S input goes through interp-by-4 and then standard Rx filters.\n"}
};
field_const_t field_const_audio_regs__aurx_ctrl1[]  = {
  {/* name */ "ctlq_aurx_itp_per", /* range */ "[6:0]", /* default */ "0d100", /* access */ "read-write", /* description */ "Number of clock cycles between interpolated samples of the Interpolate-by-4 filter in the Audio Rx. (MUST be >= 5).\n"}, 
  {/* name */ "ctlq_aurx_lpf2_dec", /* range */ "[7:7]", /* default */ "0x0", /* access */ "read-write", /* description */ "1:LPF2 Decimate-by-2 \n 0: LPF2 no decimation\n"}, 
  {/* name */ "ctlq_aurx_gainl", /* range */ "[17:8]", /* default */ "0d64", /* access */ "read-write", /* description */ "gainL (u4.6)\n"}, 
  {/* name */ "ctlq_aurx_gainr", /* range */ "[27:18]", /* default */ "0d64", /* access */ "read-write", /* description */ "gainR (u4.6)\n"}, 
  {/* name */ "ctlq_aurx_i2s_del", /* range */ "[30:28]", /* default */ "0d3", /* access */ "read-write", /* description */ "Number of sclk cycles to delay of I2S valid strobe by.\n"}, 
  {/* name */ "dummy_field", /* range */ "[31:31]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__aenc_ctrl0[]  = {
  {/* name */ "ctlq_aenc_pkt_fifo_th", /* range */ "[2:0]", /* default */ "0x2", /* access */ "read-write", /* description */ "Encoder Packet FIFO fill threshold.\n"}, 
  {/* name */ "ctlq_aenc_size", /* range */ "[13:3]", /* default */ "0d507", /* access */ "read-write", /* description */ "nSamplesPerBlk\n"}, 
  {/* name */ "ctlq_aenc_mode", /* range */ "[15:14]", /* default */ "0x0", /* access */ "read-write", /* description */ "0:generic \n 1:Apple \n 2:MSFT\n"}, 
  {/* name */ "ctlq_aenc_fsamppredic", /* range */ "[17:17]", /* default */ "0x1", /* access */ "read-write", /* description */ ""firstSampleAsPredic"\n"}, 
  {/* name */ "ctlq_aenc_skip_fsamp", /* range */ "[18:18]", /* default */ "0x1", /* access */ "read-write", /* description */ ""UsePredicAsFirstSample"\n"}, 
  {/* name */ "ctlq_aenc_predic_end", /* range */ "[19:19]", /* default */ "0x1", /* access */ "read-write", /* description */ ""LittleEndian4Predict" \n 1:little endian \n 0:big endian\n"}, 
  {/* name */ "ctlq_aenc_lsb4first", /* range */ "[20:20]", /* default */ "0x1", /* access */ "read-write", /* description */ "LSB4FIRSTSAMPLE from Matlab\n"}, 
  {/* name */ "ctlq_aenc_applepredic", /* range */ "[21:21]", /* default */ "0x0", /* access */ "read-write", /* description */ "Set to "1" in Apple Mode, clear to "0" for all other modes.\n"}, 
  {/* name */ "ctlq_aenc_rst_stepidx", /* range */ "[22:22]", /* default */ "0x0", /* access */ "read-write", /* description */ "Reset for "stepidx" in base encoder. Useful for restarting from scratch.\n"}, 
  {/* name */ "ctlq_aenc_rst_predict", /* range */ "[23:23]", /* default */ "0x0", /* access */ "read-write", /* description */ "Reset for "predict" in base encoder. Useful for restarting from scratch.\n"}, 
  {/* name */ "ctlq_aenc_wr_priority", /* range */ "[27:24]", /* default */ "0x3", /* access */ "read-write", /* description */ "If Packet FIFO (one that writes into the RAM) has more than this number of elements then it has priority\n"}, 
  {/* name */ "dummy_field", /* range */ "[31:28]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__aenc_ctrl1[]  = {
  {/* name */ "ctlq_aenc_max_addr", /* range */ "[10:0]", /* default */ "0d2047", /* access */ "read-write", /* description */ "Determines how big of a buffer that the Encoder can have (in bytes). Max value is 2047.\n"}, 
  {/* name */ "dummy_field", /* range */ "[15:11]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__aenc_stat0[]  = {
  {/* name */ "sts_aenc_pkt_fifo_fill", /* range */ "[3:0]", /* default */ "0x0", /* access */ "read-only", /* description */ "Number of bytes in Packet FIFO - bytes waiting to be written into RAM\n"}, 
  {/* name */ "sts_aenc_dma_fifo_rptr", /* range */ "[6:4]", /* default */ "0x0", /* access */ "read-only", /* description */ "Read pointer of DMA FIFO - bytes that have been read out of RAM waiting for DMA engine\n"}, 
  {/* name */ "sts_aenc_dma_fifo_wptr", /* range */ "[10:8]", /* default */ "0x0", /* access */ "read-only", /* description */ "Write pointer of DMA FIFO - bytes that have been read out of RAM waiting for DMA engine\n"}, 
  {/* name */ "sts_aenc_pk_state", /* range */ "[14:12]", /* default */ "0x0", /* access */ "read-only", /* description */ "Encoder Packet FSM\n"}, 
  {/* name */ "sts_aenc_in_state", /* range */ "[18:16]", /* default */ "0x0", /* access */ "read-only", /* description */ "Encoder Input FSM\n"}, 
  {/* name */ "dummy_field", /* range */ "[23:19]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__adec_ctrl0[]  = {
  {/* name */ "ctlq_adec_size", /* range */ "[10:0]", /* default */ "0d507", /* access */ "read-write", /* description */ "nSamplesPerBlk\n"}, 
  {/* name */ "ctlq_adec_mode", /* range */ "[13:12]", /* default */ "0x0", /* access */ "read-write", /* description */ "0:generic   1:Apple   2:MSFT\n"}, 
  {/* name */ "ctlq_adec_predicfsamp", /* range */ "[14:14]", /* default */ "0x1", /* access */ "read-write", /* description */ "UsePredicAsFirstSamp\n"}, 
  {/* name */ "ctlq_adec_predic_end", /* range */ "[15:15]", /* default */ "0x1", /* access */ "read-write", /* description */ "LittleEndian4Predict       1:little endian   0:big endian\n"}, 
  {/* name */ "ctlq_adec_lsb4first", /* range */ "[16:16]", /* default */ "0x1", /* access */ "read-write", /* description */ "LittleEndian4Predict       1:little endian   0:big endian\n"}, 
  {/* name */ "ctlq_adec_rst_stepidx", /* range */ "[17:17]", /* default */ "0x0", /* access */ "read-write", /* description */ "Reset for "stepidx" in base decoder. Useful for restarting from scratch.\n"}, 
  {/* name */ "ctlq_adec_rst_predict", /* range */ "[18:18]", /* default */ "0x0", /* access */ "read-write", /* description */ "Reset for "predict" in base encoder. Useful for restarting from scratch.\n"}, 
  {/* name */ "ctlq_adec_max_addr", /* range */ "[29:19]", /* default */ "0d2047", /* access */ "read-write", /* description */ "Determines how big of a buffer that the Decoder can have (in bytes). Max value is 2047 \n"}, 
  {/* name */ "dummy_field", /* range */ "[31:30]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__adec_ctrl1[]  = {
  {/* name */ "ctlq_adec_rd_priority", /* range */ "[13:10]", /* default */ "0x4", /* access */ "read-write", /* description */ "If In-FIFO has less than or equal to this number of bytes in its FIFO, then it gets priority for arbiter\n"}, 
  {/* name */ "ctlq_adec_dma_req_lim", /* range */ "[27:16]", /* default */ "0d2040", /* access */ "read-write", /* description */ "Only issue DMA requests if the Input RAM has fewer than this number of bytes\n"}, 
  {/* name */ "dummy_field", /* range */ "[31:28]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__adec_stat0[]  = {
  {/* name */ "sts_adec_pcm_reading", /* range */ "[12:12]", /* default */ "0x0", /* access */ "read-only", /* description */ "\n"}, 
  {/* name */ "sts_adec_pk_state", /* range */ "[15:13]", /* default */ "0x0", /* access */ "read-only", /* description */ "ADPCM Decoder Packet FSM\n"}, 
  {/* name */ "sts_adec_in_state", /* range */ "[18:16]", /* default */ "0x0", /* access */ "read-only", /* description */ "ADPCM Decoder Input FSM\n"}, 
  {/* name */ "dummy_field", /* range */ "[23:19]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_ctrl0[]  = {
  {/* name */ "ctlq_autx_itpto32_byp_lpf", /* range */ "[0:0]", /* default */ "0x0", /* access */ "read-write", /* description */ "Bypass Interp-to-32 LPF\n"}, 
  {/* name */ "ctlq_autx_itpto32_byp_up2", /* range */ "[1:1]", /* default */ "0x0", /* access */ "read-write", /* description */ "Bypass upsampling part of Interp-to-32 (but still do filtering)\n"}, 
  {/* name */ "ctlq_autx_itpto32_per", /* range */ "[11:2]", /* default */ "0xa6", /* access */ "read-write", /* description */ "Interp-to-32 period. Set to "533" for approximately 30 kHz. \n"}, 
  {/* name */ "ctlq_autx_itpto64_byp_lpf", /* range */ "[12:12]", /* default */ "0x0", /* access */ "read-write", /* description */ "Bypass Interp-to-64 LPF\n"}, 
  {/* name */ "ctlq_autx_itpto64_per", /* range */ "[21:13]", /* default */ "0x53", /* access */ "read-write", /* description */ "Interp-to-64 period. Set to "266" for approximately 60 kHz. \n"}, 
  {/* name */ "ctlq_autx_itpto128_byp_lpf", /* range */ "[22:22]", /* default */ "0x0", /* access */ "read-write", /* description */ "Bypass Interp-to-64 LPF\n"}, 
  {/* name */ "ctlq_autx_itpto128_per", /* range */ "[30:23]", /* default */ "0x1c", /* access */ "read-write", /* description */ "Interp-to-128 period. Set to "133" for approximately 120 kHz. \n"}, 
  {/* name */ "ctlq_autx_sel_in", /* range */ "[31:31]", /* default */ "0x0", /* access */ "read-write", /* description */ "Select input into Audio Tx datapath.\n0: Get input from ADPCM decoder\n1: Get input from DMA Write Shared-Memory interface (user can DMA raw PCM data into Audio Tx datapath).\n\n"}
};
field_const_t field_const_audio_regs__autx_ctrl1[]  = {
  {/* name */ "ctlq_autx_vid_nomrate", /* range */ "[22:0]", /* default */ "0x100000", /* access */ "read-write", /* description */ "Audio Tx VID nominal rate.\n"}, 
  {/* name */ "dummy_field", /* range */ "[23:23]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_ctrl2[]  = {
  {/* name */ "ctlq_autx_vid_invrate", /* range */ "[12:0]", /* default */ "0x1000", /* access */ "read-write", /* description */ "Audio Tx VID Inverse rate. \n"}, 
  {/* name */ "ctlq_autx_gainr", /* range */ "[31:22]", /* default */ "0d32", /* access */ "read-write", /* description */ "Tx gain Right (u5.5)\n"}
};
field_const_t field_const_audio_regs__autx_ctrl3[]  = {
  {/* name */ "ctlt_autx_out_per", /* range */ "[7:0]", /* default */ "0x0", /* access */ "read-write", /* description */ "Pull one sample from output FIFO once every (ctlt_autx_out_per+1) clk_spk cycles.\n"}, 
  {/* name */ "ctlt_autx_afifo_snap", /* range */ "[8:8]", /* default */ "0x0", /* access */ "read-write", /* description */ "For debug, take snapshot of FIFO status.\n"}, 
  {/* name */ "ctlq_autx_afifo_read_start", /* range */ "[11:9]", /* default */ "0x2", /* access */ "read-write", /* description */ "Start reading from FIFO when there are 2 elements.\n"}, 
  {/* name */ "ctlq_autx_afifo_keep_read", /* range */ "[12:12]", /* default */ "0x0", /* access */ "read-write", /* description */ "Once we start reading from FIFO, continuously read from it, even it means underflow.\n"}, 
  {/* name */ "ctlt_autx_afifo_clear_flow", /* range */ "[13:13]", /* default */ "0x0", /* access */ "read-write", /* description */ "Clear over/underflow signal\n"}, 
  {/* name */ "ctlq_autx_gainl", /* range */ "[25:16]", /* default */ "0d32", /* access */ "read-write", /* description */ "Tx gain Left (u5.5)\n"}, 
  {/* name */ "dummy_field", /* range */ "[31:26]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_afifo_stat0[]  = {
  {/* name */ "sts_autx_afifo_wr_pnt_rck", /* range */ "[3:0]", /* default */ "0x0", /* access */ "read-only", /* description */ "\n"}, 
  {/* name */ "sts_autx_afifo_rd_pnt_rck", /* range */ "[7:4]", /* default */ "0x0", /* access */ "read-only", /* description */ "\n"}, 
  {/* name */ "sts_autx_afifo_wr_pnt_wck", /* range */ "[11:8]", /* default */ "0x0", /* access */ "read-only", /* description */ "\n"}, 
  {/* name */ "sts_autx_afifo_rd_pnt_wck", /* range */ "[15:12]", /* default */ "0x0", /* access */ "read-only", /* description */ "\n"}, 
  {/* name */ "sts_autx_afifo_fill_rck", /* range */ "[19:16]", /* default */ "0x0", /* access */ "read-only", /* description */ "\n"}, 
  {/* name */ "sts_autx_afifo_overflow", /* range */ "[20:20]", /* default */ "0x0", /* access */ "read-only", /* description */ "\n"}, 
  {/* name */ "sts_autx_afifo_underflow", /* range */ "[21:21]", /* default */ "0x0", /* access */ "read-only", /* description */ "\n"}, 
  {/* name */ "dummy_field", /* range */ "[23:22]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_rfb_ctrl0[]  = {
  {/* name */ "ctlq_autx_rfb_target_len", /* range */ "[3:0]", /* default */ "0x3", /* access */ "read-write", /* description */ "Target fill of the FIFO.\n"}, 
  {/* name */ "ctlq_autx_rfb_ploop_dc", /* range */ "[7:4]", /* default */ "0d10", /* access */ "read-write", /* description */ "Proportional loop gain - from averaged DC error's contribution. (RFB.DC_gain_prop)  MAX of 12\n"}, 
  {/* name */ "ctlq_autx_rfb_loopbw", /* range */ "[10:8]", /* default */ "0x6", /* access */ "read-write", /* description */ "Overall Loop Bandwidth (RFB.loopBW)-4, so if you want to right-shift by 10, this value should be set to 6\n"}, 
  {/* name */ "ctlq_autx_rfb_dif_maf", /* range */ "[13:11]", /* default */ "0x0", /* access */ "read-write", /* description */ "Diff Moving Average Factor (RFB.avg_diff_factor)\n"}, 
  {/* name */ "ctlq_autx_rfb_dif_gain_lo", /* range */ "[16:14]", /* default */ "0x3", /* access */ "read-write", /* description */ "Diff Gain going into Integral accumulator (RFB.low_gain)\n"}, 
  {/* name */ "ctlq_autx_rfb_dif_gain_hi", /* range */ "[19:17]", /* default */ "0x4", /* access */ "read-write", /* description */ "Diff Gain going into Integral accumulator (RFB.high_gain)\n"}, 
  {/* name */ "ctlq_autx_rfb_dif_gain_del", /* range */ "[22:20]", /* default */ "0x4", /* access */ "read-write", /* description */ "Delay for how long to stay with "high_gain" (RFB.low_gain_delay) - Will use high gain for 2^(8+i_ctlq_dif_gain_del) number of samples.\n"}, 
  {/* name */ "ctlq_autx_rfb_dc_dec", /* range */ "[25:23]", /* default */ "0x1", /* access */ "read-write", /* description */ "DC decimation level(RFB.dcdecount) 0:run every sample,  1:every 2 samples,  2:every 4 samples...\n"}, 
  {/* name */ "ctlq_autx_rfb_dc_maf", /* range */ "[28:26]", /* default */ "0x3", /* access */ "read-write", /* description */ "DC Moving Average Factor (RFB.avg_dc_factor)\n"}, 
  {/* name */ "dummy_field", /* range */ "[31:29]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_rfb_ctrl1[]  = {
  {/* name */ "ctlq_autx_rfb_dc_gain_lo", /* range */ "[2:0]", /* default */ "0x1", /* access */ "read-write", /* description */ "DC Gain going into Integral accumulator (RFB.low_DCgain)\n"}, 
  {/* name */ "ctlq_autx_rfb_dc_gain_hi", /* range */ "[5:3]", /* default */ "0x3", /* access */ "read-write", /* description */ "DC Gain going into Integral accumulator (RFB.high_DCgain)\n"}, 
  {/* name */ "ctlq_autx_rfb_dc_fb_dis", /* range */ "[6:6]", /* default */ "0x0", /* access */ "read-write", /* description */ "Disable DC path to Integral loop (RFB.no_dc_err_FB)\n"}, 
  {/* name */ "ctlq_autx_rfb_acc_maf", /* range */ "[9:7]", /* default */ "0x6", /* access */ "read-write", /* description */ "Accumulator Moving Average Factor (RFB.avg_accu_factor)\n"}, 
  {/* name */ "ctlt_autx_rfb_freeze_stat", /* range */ "[10:10]", /* default */ "0x0", /* access */ "read-write", /* description */ "Freeze status signals for debug.\n"}, 
  {/* name */ "dummy_field", /* range */ "[15:11]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_rfb_stat0[]  = {
  {/* name */ "sts_autx_rfb_avg_dc", /* range */ "[11:0]", /* default */ "0x0", /* access */ "read-only", /* description */ "\n"}, 
  {/* name */ "sts_autx_rfb_avg_dif", /* range */ "[26:16]", /* default */ "0x0", /* access */ "read-only", /* description */ "\n"}, 
  {/* name */ "dummy_field", /* range */ "[31:27]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_rfb_stat1[]  = {
  {/* name */ "sts_autx_rfb_iloop", /* range */ "[22:0]", /* default */ "0x0", /* access */ "read-only", /* description */ "\n"}, 
  {/* name */ "dummy_field", /* range */ "[23:23]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_rfb_stat2[]  = {
  {/* name */ "sts_autx_rfb_fb_rate", /* range */ "[17:0]", /* default */ "0x0", /* access */ "read-only", /* description */ "\n"}, 
  {/* name */ "dummy_field", /* range */ "[23:18]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_sdm_ctrl0[]  = {
  {/* name */ "ctlq_autx_sdm_dither_gain", /* range */ "[1:0]", /* default */ "0x0", /* access */ "read-write", /* description */ "Sigma Delta dither gain\n"}, 
  {/* name */ "ctlq_autx_sdm_dither_order", /* range */ "[3:2]", /* default */ "0x0", /* access */ "read-write", /* description */ "Sigma Delta dither order\n"}, 
  {/* name */ "ctlq_autx_sdm_mod_index", /* range */ "[5:4]", /* default */ "0x3", /* access */ "read-write", /* description */ "Sigma Delta modulo index\n"}, 
  {/* name */ "ctlq_autx_sdm_mux_sel", /* range */ "[7:6]", /* default */ "0x0", /* access */ "read-write", /* description */ "Sigma Delta mux sel\n"}, 
  {/* name */ "ctlq_autx_sditp128_per", /* range */ "[15:8]", /* default */ "0d16", /* access */ "read-write", /* description */ "Sigma Delta interpolate-to-128 period\n"}, 
  {/* name */ "ctlq_autx_cic_itp_per", /* range */ "[23:16]", /* default */ "0d1", /* access */ "read-write", /* description */ "Sigma Delta CIC interpolator\n"}, 
  {/* name */ "ctlq_autx_sditp128_byp", /* range */ "[24:24]", /* default */ "0x0", /* access */ "read-write", /* description */ "Bypass Sigma Delta interpolate-to-128.\n"}, 
  {/* name */ "dummy_field", /* range */ "[31:25]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_sdm_stat0[]  = {
  {/* name */ "sts_autx_sdm_mux_out_l", /* range */ "[14:0]", /* default */ "0x0", /* access */ "read-only", /* description */ "Left Sigma Delta status\n"}, 
  {/* name */ "sts_autx_sdm_mux_out_r", /* range */ "[30:16]", /* default */ "0x0", /* access */ "read-only", /* description */ "Right Sigma Delta status\n"}, 
  {/* name */ "dummy_field", /* range */ "[31:31]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__adec_rate_ctrl0[]  = {
  {/* name */ "ctlq_adec_pcm_freq_den", /* range */ "[15:0]", /* default */ "0x3e8", /* access */ "read-write", /* description */ "PCM output frequency defined as:\n ADPCM_decoder_frequency*(ctlq_adec_pcm_freq_num/ctlq_adec_pcm_rate_den)\n\nNOTE: (ctlq_adec_pcm_rate_num/ctlq_adec_pcm_rate_den) MUST be less than 0.25\n"}, 
  {/* name */ "ctlq_adec_pcm_freq_num", /* range */ "[29:16]", /* default */ "0x1", /* access */ "read-write", /* description */ "See "ctlq_adec_pcm_rate_den" for description.\n"}, 
  {/* name */ "dummy_field", /* range */ "[31:30]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__adec_dma_ctrl0[]  = {
  {/* name */ "ctlq_reg_dma_rd_ack", /* range */ "[0:0]", /* default */ "0x0", /* access */ "read-write", /* description */ "If set (1), every read to register "dma_rd_dat" will automatically acknowledge the Encoder and increment the read pointer.\nUse this if the DMA engine is not working as expected. This overrides the "ack" from the DMA engine.\n\n"}, 
  {/* name */ "ctlq_reg_dma_wr_ack", /* range */ "[1:1]", /* default */ "0x0", /* access */ "read-write", /* description */ "If set (1), every write to register "dma_wr_dat" will automatically acknowledge the Decoder and increment the DMA write pointer.\nUse this if the DMA engine is not working as expected. This overrides the "ack" from the DMA engine.\n\n"}, 
  {/* name */ "dummy_field", /* range */ "[7:2]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__adec_dma_stat0[]  = {
  {/* name */ "sts_adec_bytes_in_ram", /* range */ "[11:0]", /* default */ "0x0", /* access */ "read-only", /* description */ "Number of bytes inside Decoder internal RAM.\n"}, 
  {/* name */ "sts_aenc_dma_rd_req", /* range */ "[12:12]", /* default */ "0x0", /* access */ "read-only", /* description */ "Sending out DMA read request to DMA engine.\n"}, 
  {/* name */ "sts_aenc_dma_rd_ack", /* range */ "[13:13]", /* default */ "0x0", /* access */ "read-only", /* description */ "Received read ack from DMA engine.\n"}, 
  {/* name */ "sts_adec_dma_fifo_full", /* range */ "[14:14]", /* default */ "0x0", /* access */ "read-only", /* description */ "Read DMA FIFO full.\n"}, 
  {/* name */ "sts_aenc_bytes_in_ram", /* range */ "[27:16]", /* default */ "0x0", /* access */ "read-only", /* description */ "Number of bytes inside Encoder internal RAM.\n"}, 
  {/* name */ "sts_adec_dma_wr_req", /* range */ "[28:28]", /* default */ "0x0", /* access */ "read-only", /* description */ "Sending out DMA write request to DMA engine.\n"}, 
  {/* name */ "sts_adec_dma_wr_ack", /* range */ "[29:29]", /* default */ "0x0", /* access */ "read-only", /* description */ "Received write ack from DMA engine.\n"}, 
  {/* name */ "sts_aenc_dma_fifo_full", /* range */ "[30:30]", /* default */ "0x0", /* access */ "read-only", /* description */ "Write DMA FIFO full.\n"}, 
  {/* name */ "dummy_field", /* range */ "[31:31]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__dma_read[]  = {
  {/* name */ "dma_rd_dat", /* range */ "[31:0]", /* default */ "0x0", /* access */ "read-only", /* description */ "DMA read data. Reading from this register will automatically advance the read pointer.\n"}
};
field_const_t field_const_audio_regs__adec_dma_write[]  = {
  {/* name */ "dma_wr_dat", /* range */ "[31:0]", /* default */ "0x0", /* access */ "read-write", /* description */ "DMA write data. Writing to this register will automatically advance the write pointer.\n"}
};
field_const_t field_const_audio_regs__pdm_ctrl0[]  = {
  {/* name */ "ctlq_pdm_period", /* range */ "[7:0]", /* default */ "0x3f", /* access */ "read-write", /* description */ "(ctlq_pdm_period+1) is the period of PDM output clock. This counter runs on 64 MHz clock, a period of 50 cycles would drive the PDM clock at 1.28 MHz.\n"}, 
  {/* name */ "ctlq_pdm_fall", /* range */ "[15:8]", /* default */ "0x20", /* access */ "read-write", /* description */ "PDM clock rises on count '1'. This field defines when the clock falls.\n"}, 
  {/* name */ "ctlq_pdm_lcnt", /* range */ "[23:16]", /* default */ "0x10", /* access */ "read-write", /* description */ "Sample input PDM as LEFT data on this count.\n"}, 
  {/* name */ "ctlq_pdm_rcnt", /* range */ "[31:24]", /* default */ "0x30", /* access */ "read-write", /* description */ "Sample input PDM as RIGHT data on this count.\n"}
};
field_const_t field_const_audio_regs__pdm_ctrl1[]  = {
  {/* name */ "ctlq_pdm_vcnt", /* range */ "[7:0]", /* default */ "0x31", /* access */ "read-write", /* description */ "Defines which count to send LEFT and RIGHT data into Audio Rx frontend, "valid count". \nThis value should be greater than the trailing data sample, but less than or equal to "ctlq_pdm_period".\n\n"}, 
  {/* name */ "ctlq_pdm_lsel", /* range */ "[8:8]", /* default */ "0x0", /* access */ "read-write", /* description */ "PDM Left data is sampled from  0:pdm_data0  1:pdm_data1\n"}, 
  {/* name */ "ctlq_pdm_rsel", /* range */ "[9:9]", /* default */ "0x0", /* access */ "read-write", /* description */ "PDM Right data is sampled from  0:pdm_data0  1:pdm_data1\n"}, 
  {/* name */ "dummy_field", /* range */ "[15:10]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_sm_ctrl0[]  = {
  {/* name */ "ctlq_sm_dma_rd_sel", /* range */ "[0:0]", /* default */ "0x0", /* access */ "read-write", /* description */ "This bit controls who has control of Shared Memory/DMA interface (labeled as "aenc" in ports). \n1: Audio-Tx has control of Shared Memory/DMA interface\n0: ADPCM Encoder has control\n\n"}, 
  {/* name */ "ctlt_autx_sm_en", /* range */ "[1:1]", /* default */ "0x0", /* access */ "read-write", /* description */ "Set to '1' to enable capturing data from Audio Tx datapath (from VID output) to Shared Memory.\n"}, 
  {/* name */ "ctlt_autx_sm_restart", /* range */ "[2:2]", /* default */ "0x0", /* access */ "read-write", /* description */ "Toggle to '1' to restart the Audio Tx Shared Memory interface\n"}, 
  {/* name */ "ctlq_autx_wr_priority", /* range */ "[5:4]", /* default */ "0x1", /* access */ "read-write", /* description */ "If input FIFO (one that writes into the RAM) has more than this number of elements then it has priority \n"}, 
  {/* name */ "ctlq_autx_max_addr", /* range */ "[18:8]", /* default */ "0d2047", /* access */ "read-write", /* description */ "Determines how big of a buffer that the Audio Tx can have (in 32-bit samples). Max value is 2047. \n"}, 
  {/* name */ "dummy_field", /* range */ "[23:19]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_sm_stat0[]  = {
  {/* name */ "sts_autx_rd_buf_samps", /* range */ "[11:0]", /* default */ "0x0", /* access */ "read-only", /* description */ "Total number of buffered samples for Read DMA interface.\n"}, 
  {/* name */ "sts_autx_pkt_fifo_fill", /* range */ "[14:12]", /* default */ "0x0", /* access */ "read-only", /* description */ "Packet FIFO fill \n"}, 
  {/* name */ "sts_autx_dma_fifo_fill", /* range */ "[20:16]", /* default */ "0x0", /* access */ "read-only", /* description */ "DMA FIFO fill. Number of samples in the immediate read out.\n"}, 
  {/* name */ "dummy_field", /* range */ "[23:21]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_wrsm_ctrl0[]  = {
  {/* name */ "ctlq_sm_dma_wr_sel", /* range */ "[0:0]", /* default */ "0x0", /* access */ "read-write", /* description */ "This bit controls who has control of Shared Memory/Write-DMA interface (labeled as "adec" in ports). \n1: Audio-Tx has control of Shared Memory/DMA interface\n0: ADPCM Decoder has control\n\n"}, 
  {/* name */ "ctlt_wrsm_en", /* range */ "[1:1]", /* default */ "0x0", /* access */ "read-write", /* description */ "Set to '1' to enable injecting data into Audio Tx datapath from Shared Memory (and Write-DMA's).\n"}, 
  {/* name */ "ctlt_wrsm_restart", /* range */ "[2:2]", /* default */ "0x0", /* access */ "read-write", /* description */ "Toggle to '1' to restart the Audio Tx Write Shared Memory interface\n"}, 
  {/* name */ "ctlt_wrsm_pull_en", /* range */ "[3:3]", /* default */ "0x0", /* access */ "read-write", /* description */ "Set to '1' to enable pulling data out of the Write-DMA Shared Memory interface. This effectively starts data going through the Audio-Tx datapath.\n"}, 
  {/* name */ "ctlq_wrsm_pull_start_lim", /* range */ "[5:4]", /* default */ "0x1", /* access */ "read-write", /* description */ "Only allow Audio Tx datapath to start pulling data from the Write-DMA-Shared-Memory Interface \nafter its OutFIFO has greater than or equal to this number of samples.\nDo NOT set this field to 3 unless you want to force the datapath to never pull data from the Interface.\n\n"}, 
  {/* name */ "ctlt_wrsm_rd_priority", /* range */ "[8:6]", /* default */ "0x1", /* access */ "read-write", /* description */ "Reading from shared memory has priority if DMA-FIFO less than this number of samples.\n"}, 
  {/* name */ "ctlt_wrsm_max_addr", /* range */ "[19:9]", /* default */ "0d2047", /* access */ "read-write", /* description */ "Determines how big of a buffer that the Audio Tx can have (in 32-bit samples). Max value is 2047. \n"}, 
  {/* name */ "ctlq_wrsm_dma_req_lim", /* range */ "[30:20]", /* default */ "0d2040", /* access */ "read-write", /* description */ "Only issue DMA requests if the Shared Memory has fewer than this number of words. \n"}, 
  {/* name */ "dummy_field", /* range */ "[31:31]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_wrsm_ctrl1[]  = {
  {/* name */ "ctlq_wrsm_pull_den", /* range */ "[15:0]", /* default */ "0d1000", /* access */ "read-write", /* description */ "Audio Tx Datapath samples will be pulled from Shared Memory at this frequency:\ndecoder_frequency*(ctlq_wrsm_pull_num/ctlq_wrsm_pull_den)\n\n"}, 
  {/* name */ "ctlq_wrsm_pull_num", /* range */ "[29:16]", /* default */ "0d3", /* access */ "read-write", /* description */ "See 'ctlq_wrsm_pull_den' for detailed description.\n\n"}, 
  {/* name */ "dummy_field", /* range */ "[31:30]", /* default */ "0x0", /* access */ "no-access", /* description */ ""}
};
field_const_t field_const_audio_regs__autx_wrsm_stat0[]  = {
  {/* name */ "sts_autx_wr_buf_samps", /* range */ "[11:0]", /* default */ "0x0", /* access */ "read-only", /* description */ "Total number of buffered samples for Write DMA interface. (Including FIFO's)\n"}, 
  {/* name */ "sts_wrsm_dmafifo_wfill", /* range */ "[15:12]", /* default */ "0x0", /* access */ "read-only", /* description */ "DMA FIFO fill (FIFO to handle DMA-writes-to-Shared Memory)\n"}, 
  {/* name */ "sts_wrsm_outfifo_fill", /* range */ "[18:16]", /* default */ "0x0", /* access */ "read-only", /* description */ "Out FIFO fill (FIFO to handle Shared Memory-to-Audio Tx Datapath).\n"}, 
  {/* name */ "sts_wrsm_samps_in_mem", /* range */ "[31:20]", /* default */ "0x0", /* access */ "read-only", /* description */ "Number of samples in Shared Memory (for write DMA). Does NOT include samples in FIFO.\n"}
};

field_const_array_t reg_pnt_list__audio_regs[NUM_REGS__AUDIO_REGS] = {
  { /* pfield */ field_const_audio_regs__intr_status, /* size */ 2}, 
  { /* pfield */ field_const_audio_regs__intr_mask_status, /* size */ 2}, 
  { /* pfield */ field_const_audio_regs__intr_clear, /* size */ 2}, 
  { /* pfield */ field_const_audio_regs__intr_set, /* size */ 2}, 
  { /* pfield */ field_const_audio_regs__intr_mask_set, /* size */ 2}, 
  { /* pfield */ field_const_audio_regs__intr_mask_clear, /* size */ 2}, 
  { /* pfield */ field_const_audio_regs__misc_ctrl0, /* size */ 24}, 
  { /* pfield */ field_const_audio_regs__aurx_ctrl0, /* size */ 8}, 
  { /* pfield */ field_const_audio_regs__aurx_ctrl1, /* size */ 6}, 
  { /* pfield */ field_const_audio_regs__aenc_ctrl0, /* size */ 12}, 
  { /* pfield */ field_const_audio_regs__aenc_ctrl1, /* size */ 2}, 
  { /* pfield */ field_const_audio_regs__aenc_stat0, /* size */ 6}, 
  { /* pfield */ field_const_audio_regs__adec_ctrl0, /* size */ 9}, 
  { /* pfield */ field_const_audio_regs__adec_ctrl1, /* size */ 3}, 
  { /* pfield */ field_const_audio_regs__adec_stat0, /* size */ 4}, 
  { /* pfield */ field_const_audio_regs__autx_ctrl0, /* size */ 8}, 
  { /* pfield */ field_const_audio_regs__autx_ctrl1, /* size */ 2}, 
  { /* pfield */ field_const_audio_regs__autx_ctrl2, /* size */ 2}, 
  { /* pfield */ field_const_audio_regs__autx_ctrl3, /* size */ 7}, 
  { /* pfield */ field_const_audio_regs__autx_afifo_stat0, /* size */ 8}, 
  { /* pfield */ field_const_audio_regs__autx_rfb_ctrl0, /* size */ 10}, 
  { /* pfield */ field_const_audio_regs__autx_rfb_ctrl1, /* size */ 6}, 
  { /* pfield */ field_const_audio_regs__autx_rfb_stat0, /* size */ 3}, 
  { /* pfield */ field_const_audio_regs__autx_rfb_stat1, /* size */ 2}, 
  { /* pfield */ field_const_audio_regs__autx_rfb_stat2, /* size */ 2}, 
  { /* pfield */ field_const_audio_regs__autx_sdm_ctrl0, /* size */ 8}, 
  { /* pfield */ field_const_audio_regs__autx_sdm_stat0, /* size */ 3}, 
  { /* pfield */ field_const_audio_regs__adec_rate_ctrl0, /* size */ 3}, 
  { /* pfield */ field_const_audio_regs__adec_dma_ctrl0, /* size */ 3}, 
  { /* pfield */ field_const_audio_regs__adec_dma_stat0, /* size */ 9}, 
  { /* pfield */ field_const_audio_regs__dma_read, /* size */ 1}, 
  { /* pfield */ field_const_audio_regs__adec_dma_write, /* size */ 1}, 
  { /* pfield */ field_const_audio_regs__pdm_ctrl0, /* size */ 4}, 
  { /* pfield */ field_const_audio_regs__pdm_ctrl1, /* size */ 4}, 
  { /* pfield */ field_const_audio_regs__autx_sm_ctrl0, /* size */ 6}, 
  { /* pfield */ field_const_audio_regs__autx_sm_stat0, /* size */ 4}, 
  { /* pfield */ field_const_audio_regs__autx_wrsm_ctrl0, /* size */ 9}, 
  { /* pfield */ field_const_audio_regs__autx_wrsm_ctrl1, /* size */ 3}, 
  { /* pfield */ field_const_audio_regs__autx_wrsm_stat0, /* size */ 4}
};
